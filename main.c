/*
 *    DATE: 2013-07-28
 *    AUTEUR: Jacques Deschênes
 *    DESCRIPTION: Ajout d'une mémoire RAM SPI externe pour
 *    		       augmenter la résolution de l'affichage à 200x200
 *
 */
#include <msp430.h>
#include <string.h>
#include "spi-ram.h"
#include "main.h"


#define _blank_level()  P2OUT &= ~BLK_OUT;\
						P2DIR |= BLK_OUT

#define _black_level()  P2DIR &= ~BLK_OUT;

#define SYNC_OUT  BIT1 // P2.1 TA1CCR0 output, synchro NTSC

#define  DISP_BLK 1 // affichage bloqué

volatile unsigned int ln_cnt; // compte les ligne balyage NTSC
volatile unsigned char display; // indicateur booléen activant l'ISR d'affichage.
volatile unsigned char blanked; // indicateur d'affichage bloquée pendant phase vsync.

// police de caractères 5x7  lettres majuscules et chiffre
const unsigned char font[][7]={
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // espace
	{0x04,0x04,0x04,0x04,0x04,0x00,0x04}, // !
	{0x0a,0x0a,0x0a,0x00,0x00,0x00,0x00}, // "
	{0x0a,0x0a,0x1f,0x0a,0x1f,0x0a,0x0a}, // #
	{0x04,0x0f,0x14,0x0e,0x05,0x1e,0x04}, // $
	{0x18,0x19,0x02,0x04,0x08,0x13,0x03}, // %
	{0x0c,0x12,0x14,0x08,0x15,0x12,0x0d}, // &
	{0x0c,0x04,0x08,0x00,0x00,0x00,0x00}, // '
	{0x02,0x04,0x08,0x08,0x08,0x04,0x02}, // (
	{0x08,0x04,0x02,0x02,0x02,0x04,0x08}, // )
	{0x00,0x04,0x15,0x0e,0x15,0x04,0x00}, // *
	{0x00,0x04,0x04,0x1f,0x04,0x04,0x00}, // +
	{0x00,0x00,0x00,0x00,0x0c,0x04,0x08}, // ,
	{0x00,0x00,0x00,0x1e,0x00,0x00,0x00}, // -
	{0x00,0x00,0x00,0x00,0x00,0x0c,0x0c}, // .
	{0x00,0x01,0x02,0x04,0x08,0x10,0x00}, // /
	{0x0e,0x11,0x13,0x15,0x19,0x11,0x0e}, // 0
	{0x04,0x0c,0x04,0x04,0x04,0x04,0x1f}, // 1
	{0x0e,0x11,0x02,0x04,0x08,0x10,0x1f}, // 2
	{0x1e,0x01,0x01,0x1e,0x01,0x01,0x1e}, // 3
	{0x02,0x06,0x0a,0x12,0x1f,0x02,0x02}, // 4
	{0x1f,0x10,0x10,0x1e,0x01,0x01,0x1e}, // 5
	{0x06,0x08,0x10,0x1e,0x11,0x11,0x0e}, // 6
	{0x1f,0x01,0x02,0x04,0x08,0x08,0x08}, // 7
	{0x0e,0x11,0x11,0x0e,0x11,0x11,0x0e}, // 8
	{0x0e,0x11,0x11,0x0e,0x01,0x01,0x0e}, // 9
	{0x00,0x0c,0x0c,0x00,0x0c,0x0c,0x00}, // :
	{0x00,0x0c,0x0c,0x00,0x0c,0x04,0x08}, // ;
	{0x02,0x04,0x08,0x10,0x08,0x04,0x02}, // <
	{0x00,0x00,0x1f,0x00,0x1f,0x00,0x00}, // =
	{0x08,0x04,0x02,0x01,0x02,0x04,0x08}, // >
	{0x0e,0x11,0x01,0x02,0x04,0x00,0x04}, // ?
	{0x0e,0x11,0x01,0x0d,0x15,0x15,0x0e}, // @
	{0x0e,0x11,0x11,0x1f,0x11,0x11,0x11}, // A
	{0x1e,0x11,0x11,0x1e,0x11,0x11,0x1e}, // B
	{0x0f,0x10,0x10,0x10,0x10,0x10,0x0f}, // C
	{0x1e,0x11,0x11,0x11,0x11,0x11,0x1e}, // D
	{0x1f,0x10,0x10,0x1f,0x10,0x10,0x1f}, // E
	{0x1f,0x10,0x10,0x1f,0x10,0x10,0x10}, // F
	{0x0f,0x10,0x10,0x16,0x11,0x11,0x0e}, // G
	{0x11,0x11,0x11,0x1f,0x11,0x11,0x11}, // H
	{0x0e,0x04,0x04,0x04,0x04,0x04,0x0e}, // I
	{0x0f,0x01,0x01,0x01,0x01,0x12,0x0c}, // J
	{0x11,0x12,0x14,0x18,0x14,0x12,0x11}, // K
	{0x10,0x10,0x10,0x10,0x10,0x10,0x1f}, // L
	{0x11,0x1b,0x15,0x11,0x11,0x11,0x11}, // M
	{0x11,0x11,0x19,0x15,0x13,0x11,0x11}, // N
	{0x0e,0x11,0x11,0x11,0x11,0x11,0x0e}, // O
	{0x1e,0x11,0x11,0x1e,0x10,0x10,0x10}, // P
	{0x0e,0x11,0x11,0x11,0x15,0x13,0x0f}, // Q
	{0x1e,0x11,0x11,0x1e,0x14,0x12,0x11}, // R
	{0x0f,0x10,0x10,0x0e,0x01,0x01,0x1e}, // S
	{0x1f,0x04,0x04,0x04,0x04,0x04,0x04}, // T
	{0x11,0x11,0x11,0x11,0x11,0x11,0x0e}, // U
	{0x11,0x11,0x11,0x11,0x11,0x0a,0x04}, // V
	{0x11,0x11,0x11,0x15,0x15,0x1b,0x11}, // W
	{0x11,0x11,0x0a,0x04,0x0a,0x11,0x11}, // X
	{0x11,0x11,0x11,0x0a,0x04,0x04,0x04}, // Y
	{0x1f,0x02,0x04,0x08,0x10,0x10,0x1f}, // Z
	{0x0c,0x08,0x08,0x08,0x08,0x08,0x0c}, // [
	{0x00,0x10,0x08,0x04,0x02,0x01,0x00}, // '\'
	{0x03,0x01,0x01,0x01,0x01,0x01,0x03}, // ]
	{0x04,0x0a,0x11,0x00,0x00,0x00,0x00}, // ^
	{0x00,0x00,0x00,0x00,0x00,0x00,0x1f}, // _
	{0x08,0x04,0x02,0x00,0x00,0x00,0x00}, // `
};


unsigned char line[BYTES_PER_LINE];

void delay_ms(unsigned int ms){
	while (ms--)
		_delay_cycles(16000);
} // delay_ms()

void configure_clock(){ // MCLK et SMCLK à 16Mhz
	 BCSCTL1 = CALBC1_16MHZ;
	 DCOCTL = CALDCO_16MHZ;
}//configure_clock()

/*
void clear_screen(){
	int i;
	unsigned char* pChar;
	pChar=&frame[0][0];
    for (i=0;i<(DISP_LINES*BYTES_PER_LINE);i++){
    	*pChar++ =0;
    }
}//clear_screen()

void dot(int x, int y){
	if ((x>>3)>=BYTES_PER_LINE) return;
	frame[y][x>>3] |= (1<< (7-(x & 7)));
} // dot()

void erase_dot(int x, int y){
	if ((x>>3)>=BYTES_PER_LINE) return;
	frame[y][x>>3] &= ~(1<< (7-(x & 7)));
}//erase_dot()

void swap(int* n1, int* n2){
	int t;
	t=*n1;
	*n1=*n2;
	*n2=t;
}

int abs(int x){
	return x>0?x:-x;
} // abs()

// REF: http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
void line(int x0, int y0, int x1, int y1){
 int dx,dy, error,ystep,x,y;
 unsigned char steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
      swap(&x0, &y0);
      swap(&x1, &y1);
  }
  if (x0 > x1){
      swap(&x0, &x1);
      swap(&y0, &y1);
  }
   dx = (x1 - x0);
  dy = abs(y1 - y0);
  error = dx>>1;
  y = y0;
  if (y0 < y1)  ystep = 1; else ystep = -1;
  for (x=x0;x<=x1;x++){
      if (steep) dot(y,x); else dot(x,y);
      error = error - dy;
      if (error < 0){
          y = y + ystep;
          error = error + dx;
      }
  }
} // line()

void rectangle(int x0, int y0, int x1, int y1){
	line(x0,y0,x1,y0);
	line(x1,y0,x1,y1);
	line(x0,y1,x1,y1);
	line(x0,y0,x0,y1);
} // rectangle()


void draw_char(int x, int y,  unsigned char c){
int bit,row,byte;

	if (c>='a') c -=32;
    if (c<' ' || c>'z') return;
    c -= ' ';
    for (row=0;row<7;row++){
		byte=font[c][row];
		for (bit=4;bit>=0;bit--){
			if (x>=(8*BYTES_PER_LINE-1))
				break;
			if (byte & (1<<bit))
				dot(x,y);
			else
				erase_dot(x,y);
			x++;
		}//for(bit...
		x-=5;
		y++;
	}// for (row...
} // draw_char()


const char msg[]="MSP430G2553 B/W NTSC video demo.";


void print(int x, int y, const char* str){
int idx=0;
	while  (x<(8*BYTES_PER_LINE-6) && (str[idx]!=0)){
		draw_char(x,y,str[idx]);
		idx++;
		x+=6;
	}

}// print()
*/


#include "loup.h"
/*
unsigned char left2right_byte(unsigned char byte){
	int i,n;
	n=0;
	for (i=0;i<8;i++){
		n <<=1;
		if (byte & (1<<i)){
			n += 1;
		}
	}
	return n;
}// left2right_byte()
*/
void copy_img_2_sram(){//copie l'image qui est dans la flash vers SPI RAM
	int i,l;
	for (l=0;l<233;l++){
		for (i=0;i<22;i++){
			line[i]=loup[l][i];
		}
		line[i]=0;
		write_sram_bytes(BYTES_PER_LINE*l,&line[0],BYTES_PER_LINE);
	}
}// copy_2_sram()

/*
 * main.c
 */
void main(void) {
    WDTCTL = WDTPW | WDTHOLD;	// Stop watchdog timer
    configure_clock();
    P2DIR = SYNC_OUT;  // P2.1 en sortie
    P2SEL = SYNC_OUT; //minuterie sur P2.1
    // configuration SPI RAM
    sram_init(SRAM_SEQ_MODE,SRAM_SMCLK, 4);
    copy_img_2_sram();
    //configuration minuterie 1 pour syncho NTSC
    TA1CCR0=H_LINE;
    TA1CCR1=H_LINE-H_SYNC; // commence avec une synchro verticale
    TA1CCR2=H_DISPLAY_DELAY;
    TA1CCTL1=OUTMOD_3; // mode toggle/set
    TA1CCTL0 = CCIE;
    TA1CCTL2 |= CCIE;
    TA1CTL = TASSEL_2+MC_1; // SMCLK, UP mode
    _enable_interrupts();
	ln_cnt=1;
	display=0;
	blanked=1;
	_blank_level();
	while (1){
	}//while(1)
}//main()

/*
#pragma vector=TIMER1_A0_VECTOR
__interrupt void ta1_ccr0_isr(void){ // synchronisation NTSC progressif
		ln_cnt++;
		switch (ln_cnt){
		case 4:
			TA1CCR1=H_SYNC;
			break;
		case 20:
			blanked=0;
			_enable_sram();
			SRAM_TXBUF = SRAM_READ;
			_wait_txifg();
			SRAM_TXBUF=0;
			_wait_txifg();
			SRAM_TXBUF=0;
			_wait_txifg();
		case FIRST_LINE:  // première avec affichage
			display=1;
	        break;
		case LAST_LINE:  // dernière ligne avec affichage
			display=0;
			_disable_sram();
			break;
		case 263:
			ln_cnt=1;
			TA1CCR1=H_LINE-H_SYNC;
			blanked=1;
			break;
		default:;
		}

} // ta1_ccr0_isr()


#pragma vector=TIMER1_A1_VECTOR
__interrupt void ta1_ccrx_isr(void){
	unsigned int i;
	if (TA1IV!=TA1IV_TACCR2 || blanked) return;
	_black_level();
	if (display){
		_nop();
		_nop();
		_nop();
		for (i=0;i<BYTES_PER_LINE;i++){
			SRAM_TXBUF=0;
			_wait_txifg();
			line[i]=SRAM_RXBUF;
		}
		while (SRAM_SPI_STAT & UCBUSY);
	}
	while (TA1R<950);
	_blank_level();
}
*/

#pragma vector=ADC10_VECTOR
#pragma vector=COMPARATORA_VECTOR
#pragma vector=NMI_VECTOR
#pragma vector=PORT1_VECTOR
#pragma vector=PORT2_VECTOR
#pragma vector=TIMER0_A0_VECTOR
#pragma vector=TIMER0_A1_VECTOR
#pragma vector=USCIAB0RX_VECTOR
#pragma vector=USCIAB0TX_VECTOR
#pragma vector=WDT_VECTOR
__interrupt void unsused(void){
	return;
}
